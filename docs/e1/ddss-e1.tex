\documentclass[twoside,a4paper,10pt]{article}
\usepackage[top=2.54cm,bottom=2.54cm,left=2.54cm,right=2.54cm]{geometry}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
%\usepackage[colorinlistoftodos]{todonotes}
\usepackage{url}

\usepackage[hidelinks]{hyperref}
\usepackage{tabularx}
%\usepackage{ref}

%%%

\pagenumbering{arabic}
\usepackage{fancyhdr}

\pagestyle{fancy}
% Shows section number and name
\renewcommand{\sectionmark}[1]{\markright{#1}{}}
% Clear previous styles
\fancyhf{}
\fancyhead{}
\fancyhead[RO]{\thepage}
\fancyhead[LO]{\rightmark}
\fancyhead[RE]{BitTorrent Tracker: deliverable 1}
\fancyhead[LE]{\thepage}
\fancyfoot{}
% Other modifiers
%\fancyfoot[LE,RO]{\thepage}
%\fancyfoot[LO,CE]{Something}
%\fancyfoot[CO,RE]{Author Name}

\title{BitTorrent Tracker: deliverable 1\\
  Group 01}
\author{Irene DÃ­ez \and Jesus Sesma}

\begin{document}
\date{}
\maketitle

%\begin{abstract}
%Your abstract.
%\end{abstract}

\section{Architectural design}

Figure~\ref{fig:arch} shows the architectural design of the BitTorrent Tracker.
All the tracker swarm members receive UDP multicast requests from the peers;
however, just the master answers.
The communication between the peers is done via UDP, and the
tracker's instances contemplate UDP/JMS communication among them.

\begin{figure}[h]
  \centering
  \includegraphics[width=\textwidth]{vp/architectural-design.pdf}
  \caption{\label{fig:arch}Architectural design of the Tracker.}
\end{figure}

\section{Functionality}

\begin{table}
  \centering
  \begin{tabularx}{\linewidth}{l l X}
    Identifier & Entity & Description \\ \hline\hline \\
    Peer Info Sender & Master tracker (MT) & Sends information about the peers
    and the content they have available. \\
    Master DB Fault Tolerance System (M-DFTS) & MT & Composed of the
    \emph{DB Manager} and \emph{Master Consensus System}, ensures that the
    DB is replicated among all the swarm members.\\
    Master Consensus System & MT & This component manages the DB
    replication.\\
    Master Election System & Tracker slaves (TS) & Chooses a new master among
    the slaves when the previous one has fallen.\\
    Slave DB Fault Tolerance System (S-DFTS) & TS & Composed of a
    \emph{DB Manager} and a \emph{Slave Consensus System}, listens to the
    M-DFTS' orders to ensure the DB replication in the slave.\\
    Slave Consensus System & TS &  Ensures the DB replication of
    the slave.\\
    Peer Info Requester & Peers (P) & Requests information about the peers and
    the available contents.\\
    Download Manager & P & This component handles the downloads in the
    clients.\\
    Upload Manager & P & This component handles the uploads in the clients. \\
    Cluster Fault Tolerance System & MT and TS &
    In charge of sending keep-alive messages among all the members of the
    swarm.\\
    DB Manager & MT, TS and P & Interface with the
    DB system.\\
  \end{tabularx}
  \caption{\label{tab:fun-entities}Summary of the functionality
    implemented in each entity.}
\end{table}

The tracker's functionality is summarised in table~\ref{tab:fun-entities}.
The following list describes more thoroughly the functions previously shown in
table~\ref{tab:fun-entities} that each component is responsible for:

\begin{itemize}
\item Master tracker
  \begin{itemize}
  \item \emph{Cluster Fault Tolerance System}: this component is implemented
    in all the tracker's instances, and it is in charge of knowing the state
    of all the instances. This component sends and receives Keepalive (KA)
    messages from all the instances of the cluster.
    When the master dies sends a
    notification to the \emph{Master Election System} to start the new master
    election process.
  \item \emph{Peer Info Sender}: answers to a client's information request 
    sending
    information about the available peers with a specific content.
  \item \emph{Master DB Fault Tolerance System}
    \begin{itemize}
    \item \emph{DB Manager}: handles the Master-Slave database schema described
      at Section~\ref{sec:data-schema}, see figure~\ref{fig:schema-MS}.
    \item \emph{Master Consensus System}: it has two main functions, (i) when a
      DB transaction needs to be propagated among all the instances,
      this component is in charge of coordinating such event by waiting for all
      the instances to be ready, and transmitting the order; (ii) when a
      new slave is created it sends the necessary information to keep its
      DB up to date.
    \end{itemize}
  \end{itemize}
\item Tracker slaves
  \begin{itemize}
  \item \emph{Cluster Fault Tolerance System}: refer to the Master Tracker's
    description of this item.
  \item \emph{Master Election System}: it is notified by the
    \emph{Cluster Fault Tolerance System} about a failure in the Master. This
    component selects a new master among the available slaves. When activated,
    and while the Master election process lasts, the tracker will not listen to
    the clients requests.
  \item \emph{Slave DB Fault Tolerance System}
    \begin{itemize}
    \item \emph{DB Manager}: refer to the Master Tracker's description of this
      item.
    \item \emph{Slave Consensus System}: this component has two functions; on
      the one hand
      (i) when the \emph{Master Consensus System} requests an operation to be
      propagated, checks the slave's status and prepares it to do such
      operation; when the slave is ready, notifies the master, and finally, when
      the master orders to commit, complies. On the other hand, (ii) when the
      slave is a brand-new instance, it requests the latest DB information to
      the master and waits for its instructions to commit.
    \end{itemize}
  \end{itemize}
\item Peers
  \begin{itemize}
  \item \emph{Peer Info Requester}: requests information to the tracker about
    the available peers with some content.
  \item \emph{Download Manager}: manages the download process.
  \item \emph{Upload Manager}: manages the upload process.
  \item \emph{DB Manager}: handles the Peer database schema described at
    Section~\ref{sec:data-schema}, see figure~\ref{fig:schema-P}.
  \end{itemize}
\end{itemize}


\section{Data schema}\label{sec:data-schema}

Our system contemplates two different database schemas, on the one hand the
tracker's master and slaves will implement the schema shown in
figure~\ref{fig:schema-MS}. This schema has two tables: (i) \texttt{PEER-INFO}
where information regarding the peers' host and ports is stored; and (ii)
\texttt{CONTENTS}, where the tracker will store which peers have available some
specific content. Both tables' fields are self-descriptive.

\begin{figure}[h]
  \centering
  \texttt{PEER-INFO (\underline{id:INTEGER}, host:VARCHAR(255), port:INTEGER)}
  
  \texttt{CONTENTS (\underline{sha1:STRING(40)}, \underline{peer\_id:INTEGER})}
  
  \centering
  \caption{\label{fig:schema-MS}DB schema for the tracker's master and slaves.}
\end{figure}

On the other hand, the peers will need to remember the
progress they have made during a download; thereby, they will store which chucks
they have downloaded so far for a specific file. It must be underlined that our
system will always transfer chunks of the same size, with the exception of the
last chunk, or when the content's size is inferior to our default chunk size.

This characteristic is implemented using the schema shown in
figure~\ref{fig:schema-P}, with the table \texttt{CHUNK}; its
fields are self-descriptive.

\begin{figure}[h]
  \centering
  \texttt{CHUNK (\underline{sha1:STRING(40)}, offset:INTEGER)}
  
  \centering
  \caption{\label{fig:schema-P}DB schema for the tracker's peers.}
\end{figure}

\subsection{DB technology}

We have decided to use SQLite~\cite{sqlite} as our storage technology,
mainly because we have previous experience with it; but more importantly,
because this is a didactic project without the high availability and performance
needs that a professional project's database requires.

Regarding the use of a classic SQL database over the NoSQL paradigm, since
this project implies the synchronisation of the DB over the trackers, we think
that the data should be as normalised as possible and complying to the third
normal form (3NF); thereby, we discard NoSQL databases.

\section{Interaction model design}

The following section describes the interaction model design, we have taken
into account the interaction model described at~\cite{libtorrent,bittheory},
as well as the BitTorrent specification~\cite{bep03,bep15,bep23} to make our
own.

\begin{itemize}
\item Tracker-Tracker
  \begin{enumerate}
  \item Keepalive (KA) messages: are sent every second to all the instances
    in the tracker swarm.
  \item Master election (ME) messages:
  \item Database synchronisation (DS) messages:
  \end{enumerate}
\item Tracker-Peer
  \begin{itemize}
    % FIRST
  \item Connection request: a peer requests a
    connection to the tracker to execute a specific action.

    \begin{enumerate}
    \item Peer requests the connection with the following packet (128 bits):

      \texttt{[connection\_id, action, transaction\_id]}
      
      Where:
      \begin{itemize}
      \item \texttt{connection\_id} (64 bits): initialised to
        % TODO: think of the coolest magic number
        \texttt{0xFEELDEADBAADBEEF}.
      \item \texttt{action} (32 bits): 0, for connection request.
      \item \texttt{transaction\_id} (32 bits): random number generated by the
        peer.
      \end{itemize}
    \item Master tracker answers with one of these packets (128 bits):
      \begin{enumerate}  

      \item Normal response (128 bits):
        
        \texttt{[action, transaction\_id, connection\_id]}

        Where:  
        \begin{itemize}
        \item \texttt{action} (32 bits): 0, for connection request.
        \item \texttt{transaction\_id} (32 bits)
          the \texttt{transaction\_id} previously sent by the peer.
        \item \texttt{connection\_id} (64 bits):
          the \texttt{connection\_id} generated by the tracker, which will be
          used by the peer in future requests. The peer can use the same
          \texttt{connection\_id} for one minute, the tracker will accept the
          \texttt{connection\_id} for a specific peer for two minutes.
        \end{itemize}

      \item Error response ($\geq64$ bits)\label{it:error-response}:
        
        \texttt{[action, transaction\_id, error\_string]} 

        Where:
        \begin{itemize}
        \item \texttt{action} (32 bits): 3, for error.
        \item \texttt{transaction\_id} (32 bits)
          the \texttt{transaction\_id} previously sent by the peer.
        \item \texttt{error\_string}: string describing the error, may be left
          empty.
        \end{itemize}

        This error response is used by the master at every error situation,
        thereby we will be referring to this packet in future error situations.
        
      \end{enumerate}
    \end{enumerate}

    % SECOND
  \item Peer announce: a peer requests info about a torrent.
    \begin{enumerate}
    \item Peer sends the following packet (784 bits):

      \texttt{[connection\_id, action, transaction\_id, info\_hash, peer\_id,
          downloaded, left, uploaded, event, ip, key, num\_want, port]}

      Where:
      \begin{itemize}
      \item \texttt{connection\_id} (64 bits): id given by the tracker after
        successfully establishing a connection.
      \item \texttt{action} (32 bits): 1, for announce.
      \item \texttt{transaction\_id} (32 bits): random number generated by the
        peer.
      \item \texttt{info\_hash} (160 bits): SHA-1 of the announcing torrent.
      \item \texttt{peer\_id} (160 bits): peer's id.
      \item \texttt{downloaded} (64 bits): number of bytes downloaded in this
        session.
      \item \texttt{left} (64 bits): number of bytes left to download.
      \item \texttt{uploaded} (64 bits): number of bytes uploaded in this
        session.
      \item \texttt{event} (32 bits): status; 0 none, 1 completed, 2 started,
        3 stopped.
      \item \texttt{ip} (32 bits): peer's IP address.
      \item \texttt{key} (32 bits): unique key generated by the peer.
      \item \texttt{num\_want} (32 bits): maximum number of peers wanted in the
        reply. A -1 indicates that the peer wants at most the tracker's default
        value. % 4294967295
      \item \texttt{port} (16 bits): the port the peer is listening to.
      \end{itemize}

    \item Master tracker replies with one of these packets:

      \begin{enumerate}
      \item Normal response (160 bits (min), to 4096 bits (max)
        $(160\ bits + (48\ bits * 82\ tuples))$):
        \texttt{[action, transaction\_id, interval, leechers, seeders,
            (ip, port)\ldots]}
        
        Where:
        \begin{itemize}
        \item \texttt{action} (32 bits): 1, for announce.
        \item \texttt{transaction\_id} (32 bits): the \texttt{transaction\_id}
          previously sent by the peer.
        \item \texttt{interval} (32 bits): minimum number of seconds that the
          peer must wait before reannouncing itself.
        \item \texttt{leechers} (32 bits): number of peers in the swarm still
          downloading.
        \item \texttt{seeders} (32 bits): number of peers in the swarm which
          are seeding.
        \item \texttt{ip} (32 bits): ip of a peer.
        \item \texttt{port} (16 bits): listening port of a peer.
        \end{itemize}

        The \texttt{(ip, port)} tuple is optional, it may happen that there
        aren't any seeders for the torrent.

        Note that the tracker answers by default using the Compact Peer List
        extension, which uses 6 bytes to represent a peer, as described at BEP
        23~\cite{bep23}.

      \item If there are errors ($\geq64$ bits):
        The master sends the packet described at
        \emph{Connection request}, iteration~\ref{it:error-response}.
      \end{enumerate}
    \end{enumerate}

    % THIRD
  \item Peer scraping: a peer sends information about a torrent file.
    \begin{enumerate}
    \item Peers sends info (288 bits (min), 3968 bits (max)
      $(288\ bits + (160\ bits * 23\ hashes))$):

      \texttt{[connection\_id, action, transaction\_id,
          [info\_hash]\ldots]}

      Where:
      \begin{itemize}
      \item \texttt{connection\_id} (64 bits): id given by the tracker after
        successfully establishing a connection.
      \item \texttt{action} (32 bits): 2, for scrape.
      \item \texttt{transaction\_id} (32 bits): random number generated by
        the peer.
      \item \texttt{info\_hash} (160 bits): SHA-1 of the resource (at least
        one). 
      \end{itemize}
      
    \item Master tracker replies:

      \begin{enumerate}
      \item Normal response (160 bits):

        \texttt{[action, transaction\_id, [seeders, complete, leechers]\ldots]}

        Where:
        \begin{itemize}
        \item \texttt{action} (32 bits): 2, for scrape.
        \item \texttt{transaction\_id} (32 bits): the \texttt{transaction\_id}
          previously sent by the peer.
        \item \texttt{seeders} (32 bits): number of seeders.
        \item \texttt{complete} (32 bits): number of times the torrent has
          been downloaded.
        \item \texttt{leechers} (32 bits): number of leechers.
        \end{itemize}

        The triplet \texttt{(seeders, complete, leechers)} must appear at least
        once, and repeats for each \texttt{info\_hash} asked in the scraping
        request.
        
      \item If there are errors (128 bits): The master sends the packet
        described at \emph{Connection request},
        iteration~\ref{it:error-response}.
      \end{enumerate}
    \end{enumerate}
  \end{itemize}
\end{itemize}

\section{Failure model design}

\section{Graphical interface}

\begin{figure}[!htp]
  \centering
  \includegraphics[width=0.7\textwidth]{imgs/tracker/basicInfo.png}
  \caption{\label{fig:basicInfo}Tracker: Basic information.}
\end{figure}

\begin{figure}[!htp]
  \centering
  \includegraphics[width=0.7\textwidth]{imgs/tracker/trakerSwarm.png}
  \caption{\label{fig:trackerSwarm}Tracker: List of Trackers.}
\end{figure}

\bibliographystyle{unsrt}
\bibliography{bib}

\end{document}


